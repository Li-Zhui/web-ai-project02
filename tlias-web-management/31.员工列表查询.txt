=========================一、准备工作=========================
    1.需求分析：
        查询所有员工信息，并查询出部门名称。(涉及到的表：emp、dept)
    2.准备工作
        2.1 准备数据库表 emp、emp_expr。
        2.2 准备与表结构对应的实体类 Emp、EmpExpr。
        2.3 准备三层架构的基本代码结构：EmpController、EmpService/EmpServiceImpl、EmpMapper。





=========================二、分页查询——原始方式=========================
    1.需求分析：
        如图

    2.代码实现：
        2.1 三层架构每层职责：
            如图
        2.2 三层代码：
            如图

    3.怎样为controller接收参数设置默认值：
        通过@RequestParam注解的defaultValue属性可以设置参数的默认值





=========================三、分页方式——PageHelper分页插件（一般在Service层）=========================
    1.概述：
        PageHelper是第三方提供的在Mybatis框架中用来实现分页的插件，用来简化分页操作，提高开发效率。

    2.使用插件之后的分页操作：
        如图

    3.使用步骤
        3.1 步骤简述：
            3.1.1 引入PageHelper的依赖
            3.1.2 定义Mapper接口的查询方法（无需考虑分页（ Limit关键字和聚合函数count()等 ））
            3.1.3 在Service方法中实现分页查询

        3.2 具体步骤：
            使用 PageHelper.startPage(页码 , 每页记录数) 开启分页，
            然后调用Mapper层的sql查询语句的方法，
                如图：


    4.PageHelper实现机制：
        4.1 第一步：
            扫描sql查询语句
                ——>将select后的字段语句更换为count(0)
                    ——>（如果有排序语句order by）将排序语句删除
                        ——>生成第一条sql语句（总记录数）
        4.2 第二步：
            在sql查询语句后加上Limit ？ ， ？ 进行分页操作
                ——>生成第二条sql语句（数据列表）

        4.3 第三步：
            将统计后的总记录数和数据列表封装到 Page<Emp> 对象中

    5.注意：
        5.1 定义的SQL语句结尾不能加分号';'
            否则在生成第二条语句时会出错
        5.2 PageHelper仅仅能对紧跟在其后的第一个查询语句进行分页处理





=========================四、条件分页查询=========================
    1.三层架构职责：
        如图
    2.@DateTimeFormat注解
        2.1 作用：
            为前端传递过来的日期数据指定格式
        2.2 @DateTimeFormat 注解的 pattern 属性：
            指定格式（如下）
            @DateTimeFormat(pattern = "yyyy-MM-dd")
        2.3 具体用法：
            设置在需要指定日期格式的日期/时间相关类型前





=========================五、程序优化=========================
    1.请求参数接收问题：
        1.1 问题：
            随着要接收的请求参数增加，要在三层的方法声明的形参也跟着增加，
            当方法形参过多，不利于后期的维护和管理
        1.2 优化方案：
            如果controller方法的参数较多，且未来可能继续增加，这会使得
            方法签名变得复杂难以维护，此时可以考虑将多个请求参数封装为一个对象。
        1.3 简单参数（queryString）接收方案：
            如果参数较少，controller方法中定义一个一个形参接收
            如果参数较多，controller方法中定义一个对象接收

    2.sql查询条件写死问题
        2.1 问题：
            由于sql语句需要动态的跟随着用户所输入的这些个查询的条件的变化而变化
            所以不能将sql语句写死
        2.2 优化方案：
            需要用到动态sql




=========================六、动态SQl=========================
    1.概述（使用场景）：
        随着用户的输入或外部条件的变化而变化的SQL语句，我们称为动态SQL。

    2.Mybatis提供的标签一：<if>
        2.1 作用：
            判断条件是否成立，如果条件为true，则拼接SQL。
        2.2 具体使用：
            <if test="gender != null">
                and e.gender = #{gender}
            </if>

    3.Mybatis提供的标签二：<where>
        3.1 作用：
            根据查询条件，来生成where关键字，如果所以条件不成立就不会生成where关键字。
            并会自动去除条件前面多余的and或or。
            （补充）即防止生成 where and name = 1; 这种一个查询条件用上and或or的情况
        3.2 具体使用：
            <where>
                <if test="name != null and name != ''">
                    e.name like concat('%',#{name},'%')
                </if>
                <if test="gender != null">
                    and e.gender = #{gender}
                </if>
                <if test="begin != null and end != null">
                    and e.entry_date between #{begin} and #{end}
                </if>
            </where> order by e.update_time desc
