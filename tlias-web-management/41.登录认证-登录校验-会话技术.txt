=======================================一、会话技术=============================================
1.会话：
    用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。
2.会话跟踪：
    一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。
3.会话跟踪方案：
    客户端会话跟踪技术(存储在客户端浏览器中的)：Cookie
    服务端会话跟踪技术(存储在服务器当中的)：Session
    令牌技术






=======================================二、会话技术——Cookie=============================================
1.会话跟踪技术对比
    1.1 方案一：Cookie
        优点：
            HTTP协议中支持的技术：
                当我们在服务器端再给前端响应cookie的时候
                会自动的在响应头当中添加这么一个响应头（Set-Cookie:name=value)
                告诉浏览器我们要设置cookie了

                浏览器接收到响应回来的数据之后
                发现这个响应头就会自动的将这个cookie的数据保存在浏览器本地
                并且在后续的每一次请求当中它都会将浏览器本地所保存的这个cookie会携带到服务器端

                自动携带到服务器端的原因：
                因为在http协议当中给我们提供了另外的一个请求头（Cookie:name=value）
                在cookie这个请求头当中会自动的将当前浏览器当中所保存的cookie数据一并携带到服务器端、

        缺点：
            移动端APP无法使用Cookie
            不安全，用户可以自己禁用cookie
            Cookie不能跨域（跨域区分三个维度：协议、IP/域名、端口）



    1.2 方案二：Session(底层基于Cookie)
        优点：
            存储在服务端，安全：
                客户端（浏览器）中只存储着Session的唯一标识id值（JSessionId）
                具体的数据在服务端

        缺点：
            服务器集群环境下无法直接使用Session
            Cookie的缺点



    1.3 方案三：令牌（合法身份凭证）(主流方案)
        优点：
            支持PC端、移动端
            解决集群环境下的认证问题
            减轻服务器端存储压力：
                放在客户端但客户只能使用不能禁用（结合了cookie和session）

        缺点：
            需要自己实现






=======================================三、令牌技术-JWT令牌-介绍=============================================
1.全称:
    JSON Web Token (https://jwt.io/)
    定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。



2.组成：
    第一部分：
        Header（头），记录令牌类型、签名算法等。例如：{"alg"："HS256"，"type"："JwT"}
    第二部分：
        Payload（有效载荷），携带一些自定义信息、默认信息等。例如：{"id"："1"，"username":"Tom"}
    第三部分：
        Signature（签名），防止Token被篡改、确保安全性。将header、payload融入，并加入指定秘钥，通过指定签名算法计算而来。



3.编码：
        最终 JWT令牌 前两个部分会基于 Base64编码 进行编码操作
            Base64：
                是一种基于64个可打印字符（A-Z  a-z  0-9  +  /）来表示二进制数据的编码方式。
                ‘=’在Base64编码中是一个补位符号
        第三个部分（签名）会将前两个部分融合进来并且加入我们自己指定的一个密钥，
        最后基于一定的签名算法生成这个签名。即加密之后的字符串。



4.令牌的长度：
    并不固定，取决于原始内容的大小



5.JWT令牌一生成/解析：
    引入jjwt的依赖。
    调用官方提供的工具类 Jwts 来生成或解析jwt令牌：
        String jwt = Jwts.builder()                                                          在后面指定信息来构建一个JWT令牌
                .signWith(指定签名算法 , 指定密钥)                                              在使用字符串作为密钥时也可以直接将其base64编码    例如："itheima" 对应 "aXRoZWLtYQ=="
                .addClaims(将自定义数据封装的Map集合 , )                                        添加自定义信息
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 ))      设置令牌过期时间
                .compact();                                                                 生成令牌


        Jwts.parser()                       在后面指定信息来解析一个JWT令牌（解析令牌必须要对应密钥）
                .setSigningKey("itheima")   生成和解析令牌时所使用的密钥必须完全一致
                .parseClaimsJws(token)      解析令牌
                .getBody();                 获取自定义数据(Map集合)




6.JWT令牌解析报错：
        令牌被篡改
        令牌过期






=======================================四、令牌技术-JWT令牌-登录成功后下发令牌=============================================
1.定义JWT令牌操作工具类。（基于AI）
2.登录完成后，调用工具类生成JWT令牌，并返回。